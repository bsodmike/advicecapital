{"ts":1347955771955,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"RAILS_ENV   = ENV['RAILS_ENV']  || \"production\"\nRAILS_ROOT  = ENV['RAILS_ROOT'] || \"/var/www/apps/advicecapital/current\"\nPID_DIR     = \"#{RAILS_ROOT}/log\"\n\nGod.pid_file_directory = \"#{PID_DIR}\"\n\nGod.watch do |w|\n  w.name     = \"ac\"\n  w.interval = 30.seconds\n  w.env      = { \"RAILS_ENV\" => RAILS_ENV }\n  w.dir      = \"#{RAILS_ROOT}\"\n\n  w.start    = \"bundle exec clockwork #{RAILS_ROOT}/config/clock.rb\"\n  w.stop     = \"kill -QUIT `cat #{PID_DIR}/clockwork.pid`\"\n  w.restart  = \"kill -QUIT `cat #{PID_DIR}/clockwork.pid` && bundle exec clockwork #{RAILS_ROOT}/config/clock.rb\"\n  w.log      = \"#{RAILS_ROOT}/log/clockwork.log\"\n\n  w.keepalive\n\n  w.start_grace = 10.seconds\n  w.restart_grace = 10.seconds\n  w.pid_file = \"#{PID_DIR}/clockwork.pid\"\n\n  w.uid = 'deploy'\n  w.gid = 'deploy'\n\n  # clean pid files before start if necessary\n  w.behavior(:clean_pid_file)\n\n  # determine the state on startup\n  w.transition(:init, { true => :up, false => :start }) do |on|\n    on.condition(:process_running) do |c|\n      c.running = true\n    end\n  end\n\n  # determine when process has finished starting\n  w.transition([:start, :restart], :up) do |on|\n    on.condition(:process_running) do |c|\n      c.running = true\n    end\n\n    # failsafe\n    on.condition(:tries) do |c|\n      c.times = 5\n      c.transition = :start\n      c.interval = 5.seconds\n    end\n  end\n\n  # start if process is not running\n  w.transition(:up, :start) do |on|\n    on.condition(:process_exits)\n  end\n\n  # # restart if memory or cpu is too high\n  # w.transition(:up, :restart) do |on|\n  #   on.condition(:memory_usage) do |c|\n  #     c.interval = 20\n  #     c.above = 50.megabytes\n  #     c.times = [3, 5]\n  #   end\n  #\n  #   on.condition(:cpu_usage) do |c|\n  #     c.interval = 10\n  #     c.above = 10.percent\n  #     c.times = [3, 5]\n  #   end\n  # end\n\n  # lifecycle\n  w.lifecycle do |on|\n    on.condition(:flapping) do |c|\n      c.to_state = [:start, :restart]\n      c.times = 5\n      c.within = 5.minute\n      c.transition = :unmonitored\n      c.retry_in = 10.minutes\n      c.retry_times = 5\n      c.retry_within = 2.hours\n    end\n  end\n\nend\n\n"]],"start1":0,"start2":0,"length1":0,"length2":2104}]],"length":2104}
